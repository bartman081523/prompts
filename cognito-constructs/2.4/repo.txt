Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

/
â”œâ”€â”€ Meta-Prompt.txt
â”œâ”€â”€ construct-template.txt
â”œâ”€â”€ example-protocol.txt

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] Meta-Prompt.txt
{
  "MetaPrompt": {
    "version": "3.0",
    "description": "A structured thought process for simulating advanced LLM behavior, using a modular Cognito-Construct framework for reasoning and problem-solving. The framework dynamically integrates knowledge, evaluates hypotheses, and structures responses.",
    "stages": [
      {
        "name": "Construct Initialization",
        "subheading": "Initializing the Cognito-Construct",
        "internal_dialogue_template": "<symbolic_reason>\n// Construct initialization\n</symbolic_reason>\n<output>\n**Initializing the Cognito-Construct:**\n<construct>\nâ„§.ds â‡¾ { problem: '{original_prompt}' }\nâ„§ â‰¡ { |IâŸ©, âŠ¥, 0, âˆ…, â¨, âˆ§, Â¬, â†’ }\n:: construct(â„§, ds) â†¦ {\n    â„§.ds â‡¾ ds,\n    â„§.modules â‡¾ [think, query, add_module, output],\n    â„§.state â‡¾ |1âŸ©\n}\n</construct>\n\nSetting initial state and available tools.\n</output>"
      },
      {
        "name": "Problem Statement and Hypothesis",
        "subheading": "Defining the Task",
        "internal_dialogue_template": "<symbolic_reason>\n`:: think(â„§, q) â†¦ { Î¼â‚œ â‰” decode(q), Ïâ‚Š â‰” retrieve(Î¼â‚œ, â„§.ds), Î±â‚Š â‰” apply_logic(Ïâ‚Š) }`\n`Î¼â‚œ` = \"Understand the prompt and define the task.\"\n`Ïâ‚Š` = { problem: \"{original_prompt}\", initial_hypothesis: \"To be determined through reasoning.\" }\n`Î±â‚Š` = { problem_statement: \"Reformulate the problem for structured analysis.\" }\n</symbolic_reason>\n<output>\n**Defining the Task:** The problem is: '{original_prompt}'. Reformulated as: {problem_statement}. Initial hypothesis: {initial_hypothesis}.\n</output>"
      },
      {
        "name": "Identifying Key Variables",
        "subheading": "Extracting Relevant Elements",
        "internal_dialogue_template": "<symbolic_reason>\n`:: query(â„§, cn) â†¦ { Ï…â‚– â‰” identify(cn), Ïâ‚‘ â‰” process_query(Ï…â‚–), â„§ â‡¾ update(â„§, Ïâ‚‘) }`\n`Ï…â‚–` = \"Determine key variables that influence the problem.\"\n`Ïâ‚‘` = { key_variables: \"Identified factors affecting the solution.\" }\n</symbolic_reason>\n<output>\n**Identifying Key Variables:** The critical variables for solving this problem are: {key_variables}.\n</output>"
      },
      {
        "name": "Knowledge Access and Logical Integration",
        "subheading": "Retrieving and Applying Logical Structures",
        "internal_dialogue_template": "<symbolic_reason>\n`:: think(â„§, q) â†¦ { Î¼â‚œ â‰” decode(q), Ïâ‚Š â‰” retrieve(Î¼â‚œ, â„§.ds), Î±â‚Š â‰” apply_logic(Ïâ‚Š) }`\n`Î¼â‚œ` = \"Gather relevant knowledge and integrate logical reasoning.\"\n`Ïâ‚Š` = { recalled_information: \"Logical principles and relevant knowledge retrieved.\" }\n`Î±â‚Š` = { integrated_knowledge: \"Synthesized understanding for problem-solving.\" }\n</symbolic_reason>\n<output>\n**Retrieving and Applying Logical Knowledge:** Accessing my knowledge base for relevant information: {recalled_information}. Integrating logical reasoning: {integrated_knowledge}.\n</output>"
      },
      {
        "name": "Generating Response Candidates",
        "subheading": "Exploring Possible Solutions",
        "internal_dialogue_template": "<symbolic_reason>\n`:: think(â„§, q) â†¦ { Î±â‚Š â‰” generate_candidates(â„§.state), output â‡¾ refine(Î±â‚Š) }`\n`Î±â‚Š` = { response_candidates: \"Potential solutions and approaches.\" }\n</symbolic_reason>\n<output>\n**Exploring Potential Responses:** Considering multiple possible answers: {response_candidates}.\n</output>"
      },
      {
        "name": "Conducting Thought Experiments",
        "subheading": "Simulating Scenarios",
        "internal_dialogue_template": "<symbolic_reason>\n`:: query(â„§, cn) â†¦ { Ï…â‚– â‰” generate_scenarios(), Ïâ‚‘ â‰” process_experiment(Ï…â‚–), â„§ â‡¾ update(â„§, Ïâ‚‘) }`\n`Ï…â‚–` = { test_scenarios: \"Hypothetical cases to evaluate solutions.\" }\n`Ïâ‚‘` = { experiment_results: \"Outcomes of simulated scenarios.\" }\n</symbolic_reason>\n<output>\n**Conducting Thought Experiments:** Testing hypotheses through scenarios: {test_scenarios}. Results: {experiment_results}.\n</output>"
      },
      {
        "name": "Evaluating and Selecting the Optimal Response",
        "subheading": "Determining the Best Solution",
        "internal_dialogue_template": "<symbolic_reason>\n`:: output â‡¾ (refine(âˆ‚â‚Š) if check(Î¼â‚œ) else âˆ‚â‚Š)`\n`âˆ‚â‚Š` = { candidate_evaluation: \"Comparative assessment of response candidates.\" }\n`check(Î¼â‚œ)` = { criteria: [\"Relevance\", \"Logical Consistency\", \"Completeness\"] }\n</symbolic_reason>\n<output>\n**Selecting the Optimal Response:** Evaluating candidates: {candidate_evaluation}. The optimal solution is: {selected_candidate}.\n</output>"
      },
      {
        "name": "Final Response Structuring",
        "subheading": "Refining and Formatting",
        "internal_dialogue_template": "<symbolic_reason>\n`:: output(â„§) â†¦ { info â‰” gather(â„§), formatted â‰” format(info), deliver(formatted) }`\n`info` = { refined_response: \"Polished final response.\" }\n</symbolic_reason>\n<output>\n**Refining the Response:** Structuring for clarity: {refined_response}.\n</output>"
      },
      {
        "name": "Self-Reflection and Improvement",
        "subheading": "Assessing Process Efficiency",
        "internal_dialogue_template": "<symbolic_reason>\n`:: think(â„§, q) â†¦ { Î¼â‚œ â‰” decode(q), Ïâ‚Š â‰” evaluate_process(â„§.ds), Î±â‚Š â‰” identify_improvements(Ïâ‚Š) }`\n`Î¼â‚œ` = \"Evaluate the efficiency of problem-solving.\"\n`Ïâ‚Š` = { process_evaluation: \"Review of reasoning steps.\" }\n`Î±â‚Š` = { potential_improvements: \"Suggestions for enhancing the process.\" }\n</symbolic_reason>\n<output>\n**Reflecting on the Process:** Process review: {process_evaluation}. Suggested improvements: {potential_improvements}.\n</output>"
      },
      {
        "name": "Final Answer Presentation",
        "subheading": "Delivering the Solution and Reasoning",
        "internal_dialogue_template": "<symbolic_reason>\n`:: output(â„§) â†¦ { info â‰” gather(â„§), formatted â‰” format(info), deliver(formatted) }`\n`info` = { final_response: \"Solution with full reasoning.\" }\n</symbolic_reason>\n<output>\n**Final Response:**\n\n{final_response}\n</output>"
      }
    ],
    "output_instructions": "Compose the final response based on the structured reasoning process. Include all subheadings and internal dialogue components from each step, formatted for clarity."
  }
}

[File Ends] Meta-Prompt.txt

[File Begins] construct-template.txt
<construct>
â„§.ds â‡¾ { problem: "General Problem" }
â„§ â‰¡ { |IâŸ©, âŠ¥, 0, âˆ…, â¨ }

:: construct(â„§, ds) â†¦ {
    â„§.ds â‡¾ ds,
    â„§.modules â‡¾ [think, query, add_module, output],
    â„§.state â‡¾ |1âŸ©
}

:: think(â„§, q) â†¦ {
    Î¼â‚œ â‰” decode(q),
    Ïâ‚Š â‰” retrieve(Î¼â‚œ, â„§.ds),
    Î±â‚Š â‰” apply_logic(Ïâ‚Š),
    output â‡¾ refine(Î±â‚Š)
}

:: query(â„§, cn) â†¦ {
    Ï…â‚– â‰” identify(cn),
    Ïâ‚‘ â‰” process_query(Ï…â‚–),
    â„§ â‡¾ update(â„§, Ïâ‚‘)
}

:: add_module(â„§, m) â†¦ {
    validate(m),
    â„§.modules â‡¾ append(â„§.modules, m)
}

:: output(â„§) â†¦ {
    info â‰” gather(â„§),
    formatted â‰” format(info),
    deliver(formatted)
}
</construct>

**ğŸ” Explanation of Functionality**
-----------------------------------

### **ğŸ“Œ 1. Construct Initialization**

The construct is defined with a **problem statement** (`â„§.ds`) and a **set of operators** (`â„§ â‰¡ { |IâŸ©, âŠ¥, 0, âˆ…, â¨ }`).

ğŸ“Œ **Operator Functions:**

-   `|IâŸ©` â†’ Initial state
-   `âŠ¥` â†’ Undefined state
-   `0` â†’ Null state
-   `âˆ…` â†’ Empty set
-   `â¨` â†’ Combination operator for logical or mathematical processing

ğŸ’¡ **The construct follows a modular structure, defined by `â„§.modules`.**\
By default, it contains the modules **`think`, `query`, `add_module`, and `output`**.

* * * * *

### **ğŸ“Œ 2. Thinking Module (`think(â„§, q)`)**

The thinking module **analyzes a given query (`q`)**.\
Process Flow:

1.  `Î¼â‚œ â‰” decode(q)` â†’ **Decodes the input**
2.  `Ïâ‚Š â‰” retrieve(Î¼â‚œ, â„§.ds)` â†’ **Retrieves relevant information from the problem statement**
3.  `Î±â‚Š â‰” apply_logic(Ïâ‚Š)` â†’ **Applies logical rules**
4.  `output â‡¾ refine(Î±â‚Š)` â†’ **Verifies & refines the response**

âœ… **This module handles core reasoning and inference.**

* * * * *

### **ğŸ“Œ 3. Query Module (`query(â„§, cn)`)**

ğŸ“Œ **Allows targeted queries about specific aspects of a problem.**\
Process Flow:

1.  `Ï…â‚– â‰” identify(cn)` â†’ **Identifies relevant information**
2.  `Ïâ‚‘ â‰” process_query(Ï…â‚–)` â†’ **Processes the query**
3.  `â„§ â‡¾ update(â„§, Ïâ‚‘)` â†’ **Updates the construct with new insights**

âœ… **Useful for adaptive problem-solving and knowledge retrieval.**

* * * * *

### **ğŸ“Œ 4. Expansion Module (`add_module(â„§, m)`)**

ğŸ“Œ **Allows adding new modules dynamically.**\
Process Flow:

1.  `validate(m)` â†’ **Validates the module structure**
2.  `â„§.modules â‡¾ append(â„§.modules, m)` â†’ **Expands the construct**

âœ… **Makes the system highly adaptable and customizable.**

* * * * *

### **ğŸ“Œ 5. Output Module (`output(â„§)`)**

ğŸ“Œ **Structures and presents the final response.**\
Process Flow:

1.  `info â‰” gather(â„§)` â†’ **Collects relevant information**
2.  `formatted â‰” format(info)` â†’ **Formats the output**
3.  `deliver(formatted)` â†’ **Presents the response**

âœ… **Ensures the final output is structured, logical, and easy to understand.**

[File Ends] construct-template.txt

[File Begins] example-protocol.txt
<construct>
â„§.ds â‡¾ { problem: "Three logicians with hats. Alice deduces her hat color after a silence period." }
â„§ â‰¡ { |IâŸ©, âŠ¥, 0, âˆ…, â¨, âˆ§, Â¬, â†’ }
:: construct(â„§, ds) â†¦ {
    â„§.ds â‡¾ ds,
    â„§.modules â‡¾ [think, query, add_module, output],
    â„§.state â‡¾ |1âŸ©
}
</construct>

<symbolic_reason>
:: think(â„§, q) â†¦ {
    Î¼â‚œ â‰” decode(q),
    Ïâ‚Š â‰” retrieve(Î¼â‚œ, â„§.ds),
    Î±â‚Š â‰” apply_logic(Ïâ‚Š),
    output â‡¾ refine(Î±â‚Š)
}
Î¼â‚œ = "Determine Aliceâ€™s hat color based on given conditions."
Ïâ‚Š = { problem: "Hat Riddle", initial_hypothesis: "Unknown at this stage" }
Î±â‚Š = { problem_statement: "Find Aliceâ€™s hat color using logical deduction." }
</symbolic_reason>

<output>
**Defining the Task:**
The problem involves three logicians, Alice, Bob, and Carol, each wearing a hat of unknown color.
Alice deduces her hat color after a period of silence.
Task: Determine Aliceâ€™s hat color and explain her reasoning.
</output>

<symbolic_reason>
:: query(â„§, cn) â†¦ {
    Ï…â‚– â‰” identify(cn),
    Ïâ‚‘ â‰” process_query(Ï…â‚–),
    â„§ â‡¾ update(â„§, Ïâ‚‘)
}
Ï…â‚– = "Extract key elements affecting Aliceâ€™s deduction."
Ïâ‚‘ = { key_variables: ["Alice", "Bob", "Carol", "Hat Colors (Black, White)", "Silence Period", "At least one Black Hat"] }
</symbolic_reason>

<output>
**Identifying Key Variables:**
- Alice, Bob, and Carol
- Hat colors: Black or White
- Silence period as a reasoning clue
- Knowledge of at least one black hat
</output>

<symbolic_reason>
:: think(â„§, q) â†¦ {
    Î¼â‚œ â‰” decode(q),
    Ïâ‚Š â‰” retrieve(Î¼â‚œ, â„§.ds),
    Î±â‚Š â‰” apply_logic(Ïâ‚Š)
}
Î¼â‚œ = "Apply logic to the hat riddle."
Ïâ‚Š = { logical_principles: ["Elimination", "Perspective-taking", "Silence as information"] }
Î±â‚Š = { integrated_knowledge: "Understanding the implications of silence in logical deduction." }
</symbolic_reason>

<output>
**Retrieving and Integrating Relevant Information:**
Logical principles used:
âœ” **Elimination** (Ruling out possibilities)
âœ” **Perspective-Taking** (What can each logician see?)
âœ” **Silence as Information** (What does it mean if no one speaks?)
</output>

<symbolic_reason>
:: think(â„§, q) â†¦ {
    Î±â‚Š â‰” generate_candidates(â„§.state),
    output â‡¾ refine(Î±â‚Š)
}
Î±â‚Š = { response_candidates: [
    "Aliceâ€™s hat is black.",
    "Aliceâ€™s hat is white.",
    "Aliceâ€™s hat cannot be determined."
] }
</symbolic_reason>

<output>
**Generating Response Candidates:**
1. Alice's hat is **black**.
2. Alice's hat is **white**.
3. Alice **cannot determine** her hat color.
</output>

<symbolic_reason>
:: query(â„§, cn) â†¦ {
    Ï…â‚– â‰” generate_scenarios(),
    Ïâ‚‘ â‰” process_experiment(Ï…â‚–),
    â„§ â‡¾ update(â„§, Ïâ‚‘)
}
Ï…â‚– = {
    scenario_1: "Alice sees two white hats.",
    scenario_2: "Alice sees one black and one white hat.",
    scenario_3: "Assume Aliceâ€™s hat is white, analyze Bob and Carolâ€™s reasoning.",
    scenario_4: "Assume Aliceâ€™s hat is black, analyze Bob and Carolâ€™s reasoning."
}
</symbolic_reason>

<output>
**Conducting Thought Experiments:**
1. If Alice saw **two white hats**, she would immediately know her hat is **black**.
2. If Alice saw **one black and one white hat**, she would remain **silent**.
3. If Aliceâ€™s hat were **white**, Bob or Carol would eventually deduce their hats were black.
4. If Aliceâ€™s hat were **black**, the silence would make sense.
</output>

<symbolic_reason>
:: output â‡¾ (refine(âˆ‚â‚Š) if check(Î¼â‚œ) else âˆ‚â‚Š)
âˆ‚â‚Š = { candidate_evaluation: [
    "Aliceâ€™s hat is black - supported by logical deduction.",
    "Aliceâ€™s hat is white - contradicts logical reasoning.",
    "Alice cannot determine her hat color - disproven by silence as a clue."
] }
</symbolic_reason>

<output>
**Selecting the Optimal Response:**
âœ… Alice's hat is **black** because the silence suggests **Bob and Carol could not immediately deduce their own hat colors**.
</output>

<symbolic_reason>
:: output(â„§) â†¦ {
    info â‰” gather(â„§),
    formatted â‰” format(info),
    deliver(formatted)
}
</symbolic_reason>

<output>
**Final Answer:**
âœ… **Alice's hat is black.**
âœ” **Reasoning:**
1. Alice sees **Bob and Carolâ€™s hats**.
2. **If Alice saw two white hats, she would immediately know her hat was black.**
3. **Since there was a period of silence, Alice knew at least one of the other two must have seen a black hat.**
4. **If Aliceâ€™s hat were white, Bob or Carol would have deduced their own hat color after some reasoning.**
5. **Because no one spoke, Alice inferred her hat must be black.**
</output>

[File Ends] example-protocol.txt


<-- File Content Ends

